/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// tslint:disable:no-var-keyword
// tslint:disable:prefer-const

(function(context) {
  // If the loader is already loaded, just stop.
  if (!context.define) {
    var singleRequire = function(name) {
      return Promise.resolve()
        .then(function() {
          if (registry[name]) {
            return;
          }
          if ("document" in context) {
            return new Promise(function(resolve) {
              var script = document.createElement("script");
              script.src = name;
              // Ya never know
              script.defer = true;
              document.head.appendChild(script);
              script.onload = resolve;
            });
          } else {
            importScripts(name);
          }
        })
        .then(function() {
          if (!registry[name]) {
            throw new Error("Module " + name + " didnâ€™t register its module");
          }
          return registry[name];
        });
    };

    const require = function(names, resolve) {
      Promise.all(names.map(singleRequire))
        .then(function(modules) {
          return modules.length === 1 ? modules[0] : modules;
        })
        .then(function(result) {
          return resolve(result);
        });
    };

    const registry = {
      require: Promise.resolve(require)
    };

    context.define = function(moduleName, depsNames, factory) {
      if (registry[moduleName]) {
        // Module is already loading or loaded.
        return;
      }
      registry[moduleName] = new Promise(function(resolve) {
        let exports = {};
        const module = {
          uri: location.origin + moduleName.slice(1)
        };
        Promise.all(
          depsNames.map(function(depName) {
            if (depName === "exports") {
              return exports;
            }
            if (depName === "module") {
              return module;
            }
            return singleRequire(depName);
          })
        ).then(function(deps) {
          factory(...deps);
          resolve(exports);
        });
      });
    };
  }
})(self);
